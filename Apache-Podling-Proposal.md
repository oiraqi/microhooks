## Abstract
Microhooks will be a framework that streamlines the development of microservices

Proposal
Microhooks aims at allowing microservice developers to focus on their business logic while declaratively expressing low-level, recurring needs, such as inter-service communication, brokering, event management, data replication, and distributed transaction management. Based on the inversion of control, the materialized view pattern, and the two-phase commit protocol among others, our framework automatically generates and injects the corresponding artifacts. It leverages 100% build time code introspection and instrumentation, as well as context building, for optimized runtime performance. From the user perspective, Microhooks exposes an intuitive, container-agnostic, broker-neutral, and ORM framework-independent API.

## Background
Microservices is an architectural style and model for the development of loosely coupled, isolated, but collaborating services constituting a single application. Therefore, these microservices are highly maintainable, easily testable, and independently deployable. This architectural pattern aims at addressing the problems encountered in traditional tiered and monolithic architectures. Such problems can be related to the following non-functional requirement areas: scalability, maintainability, and security. There are several microservices patterns. But, we focus here on three patterns that are the most relevant to our project:
- The Database-per-Service Pattern: This pattern stems from the well-known domain-driven design (DDD) whereby a large business domain is broken down into several more cohesive and smaller (sub)domains, each with well-defined boundaries. Then, objects or entities within each domain are identified and modeled. Following DDD, a traditional large data model would rather become a set of smaller data models, each representing a specific domain. DDD can be leveraged to segregate microservices so that each bounded context corresponds to a microservice describing a distinct problem area. Each microservice represents an abstraction over its own data model, hence its own database. Each microservice should be able to independently store and retrieve information from its own data store. This is the database-per-service pattern.
- The Data Replication / Materialized View Pattern: Following the CAP theorem, we can only have two of the following properties: Consistency, Availability, and Partitioning. Because of the distributed nature of microservices, especially when adopting the database-per-service pattern, data partitioning is there. Hence, we shall choose between consistency and availability. The consistency of the data is achieved through the traditional way of implementing distributed systems, where each piece of information required by a microservice needs to be requested from the microservice owning that data. Not only does this approach consume network resources, but it also adds an internal load of requests that needs to be processed by the concerned microservice in addition to the regular load of external requests submitted by clients. For this reason, we favor availability over consistency, which we rather substitute with eventual consistency. This is achieved by making sure to have data replicated where it is or will be needed. The implementation of this pattern is done through microservices maintaining materialized views constituted of data owned by other microservices.
- The Command Query Responsibility Segregation Pattern: This is another microservices pattern that further enhances the decoupling of components and helps improve the scalability of the architecture \cite{CQRS}. CQRS is a principle that dictates that the data model for a service be divided into two parts: a command model, which is responsible for writes, and a query model, which is responsible for reads. This separation of concerns allows for more flexibility and scalability in the design of a microservice. It also helps to reduce coupling between services as each service can focus on its own data model and business logic.

## Rationale
The microservices architectural model has gained widespread adoption in recent years thanks to its ability to deliver high scalability and maintainability. However, the development process of microservices-based applications can be complex and challenging. Indeed, it often requires developers to manage a large number of distributed components with the burden of handling low-level, recurring needs, inherent to distributed systems. The associated costs may outweigh the benefits expected from the microservice architecture, and consequently discourage from its adoption. Microhooks strives to alleviate such costs by making the so-called low-level details completely transaprent to developers.

## Current Status
So far, Microhooks initial functional and non-functional requirements have been specified, and the corresponding high-level design, detailed design, and implementation have been performed. Microhooks evaluation against state-of-the-art practices has demonstrated its effectiveness in drastically reducing code size and complexity, without incurring any considerable cost on performance.

## Meritocracy
Microhooks was originally created by Omar Iraqi in 2022. We highly welcome other developers around the world to write and be part of Microhooks success story with us. We are and remain committed to elect any developer who has made enough good contributions as a committer. Moreover, we are committed to elect active contributors to the PMC.

## Community
A community is yet to be built and nurtured. But we are confident Microhooks will gain a growing popularity within the developer community since it address real-life and daily issues related to the development of microservices, in a transparent way, using an intuitive, annotation-based, container-agnostic, broker-neutral, and ORM-framework-independent API.

## Git Repositories
https://github.com/oiraqi/microhooks